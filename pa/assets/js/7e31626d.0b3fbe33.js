"use strict";(globalThis.webpackChunkrobotics_book=globalThis.webpackChunkrobotics_book||[]).push([[577],{4126:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module4-vla/bipedal-locomotion","title":"Bipedal Locomotion","description":"Overview","source":"@site/docs/module4-vla/bipedal-locomotion.md","sourceDirName":"module4-vla","slug":"/module4-vla/bipedal-locomotion","permalink":"/docusaurus-robotics-book/pa/module4-vla/bipedal-locomotion","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1764862720000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid Robot Kinematics","permalink":"/docusaurus-robotics-book/pa/module4-vla/humanoid-kinematics"},"next":{"title":"Manipulation and Grasping","permalink":"/docusaurus-robotics-book/pa/module4-vla/manipulation-grasping"}}');var i=t(4848),r=t(8453);const l={},a="Bipedal Locomotion",s={},c=[{value:"Overview",id:"overview",level:2},{value:"Why Bipedal Locomotion is Hard",id:"why-bipedal-locomotion-is-hard",level:2},{value:"Challenges",id:"challenges",level:3},{value:"Static vs. Dynamic Walking",id:"static-vs-dynamic-walking",level:3},{value:"Fundamentals of Balance",id:"fundamentals-of-balance",level:2},{value:"Center of Mass (CoM)",id:"center-of-mass-com",level:3},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Support Polygon",id:"support-polygon",level:3},{value:"Gait Patterns",id:"gait-patterns",level:2},{value:"Walking Phases",id:"walking-phases",level:3},{value:"Gait Cycle",id:"gait-cycle",level:3},{value:"Implementing a Simple Gait",id:"implementing-a-simple-gait",level:3},{value:"Preview Control",id:"preview-control",level:2},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:3},{value:"Capture Point Theory",id:"capture-point-theory",level:2},{value:"Capture Point",id:"capture-point",level:3},{value:"Linear Inverted Pendulum Model (LIPM)",id:"linear-inverted-pendulum-model-lipm",level:2},{value:"Whole-Body Control",id:"whole-body-control",level:2},{value:"Hierarchical Quadratic Programming (HQP)",id:"hierarchical-quadratic-programming-hqp",level:3},{value:"Practical Exercises",id:"practical-exercises",level:2},{value:"Exercise 1: ZMP Computation",id:"exercise-1-zmp-computation",level:3},{value:"Exercise 2: Gait Generation",id:"exercise-2-gait-generation",level:3},{value:"Exercise 3: Push Recovery",id:"exercise-3-push-recovery",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Resources",id:"resources",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"bipedal-locomotion",children:"Bipedal Locomotion"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Bipedal locomotion is one of the most challenging aspects of humanoid robotics. Unlike wheeled or quadruped robots, bipedal robots must constantly maintain balance while dynamically shifting weight between two legs."}),"\n",(0,i.jsx)(n.h2,{id:"why-bipedal-locomotion-is-hard",children:"Why Bipedal Locomotion is Hard"}),"\n",(0,i.jsx)(n.h3,{id:"challenges",children:"Challenges"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Underactuation"}),": Only two contact points with the ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Instability"}),": Must actively maintain balance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High-dimensional control"}),": 12+ DOF in legs alone"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Energy efficiency"}),": Biological walking is remarkably efficient; robots lag behind"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robustness"}),": Must handle uneven terrain, disturbances, obstacles"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"static-vs-dynamic-walking",children:"Static vs. Dynamic Walking"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Static Walking"}),(0,i.jsx)(n.th,{children:"Dynamic Walking"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Center of Mass (CoM) always over support polygon"}),(0,i.jsx)(n.td,{children:"CoM may be outside support polygon"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Slow and stable"}),(0,i.jsx)(n.td,{children:"Fast and natural"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Low energy efficiency"}),(0,i.jsx)(n.td,{children:"Higher efficiency possible"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Safe but limited"}),(0,i.jsx)(n.td,{children:"Enables running, jumping"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"fundamentals-of-balance",children:"Fundamentals of Balance"}),"\n",(0,i.jsx)(n.h3,{id:"center-of-mass-com",children:"Center of Mass (CoM)"}),"\n",(0,i.jsx)(n.p,{children:"The average position of all mass in the robot:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def compute_com(robot_state):\n    """Compute center of mass position"""\n    total_mass = 0\n    weighted_pos = np.zeros(3)\n\n    for link in robot_state.links:\n        mass = link.mass\n        position = link.position\n\n        weighted_pos += mass * position\n        total_mass += mass\n\n    com = weighted_pos / total_mass\n    return com\n'})}),"\n",(0,i.jsx)(n.h3,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,i.jsx)(n.p,{children:"The point on the ground where the net moment of ground reaction forces is zero."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ZMP Stability Criterion"}),": Robot is stable if ZMP is inside the support polygon (footprint area)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def compute_zmp(robot_state, forces):\n    """Compute Zero Moment Point"""\n\n    # Simplified ZMP calculation\n    # Full calculation involves all forces and torques\n\n    com = compute_com(robot_state)\n    com_accel = robot_state.com_acceleration\n\n    # Simplified ZMP (assuming flat ground at z=0)\n    zmp_x = com[0] - (com[2] / 9.81) * com_accel[0]\n    zmp_y = com[1] - (com[2] / 9.81) * com_accel[1]\n\n    return np.array([zmp_x, zmp_y, 0])\n'})}),"\n",(0,i.jsx)(n.h3,{id:"support-polygon",children:"Support Polygon"}),"\n",(0,i.jsx)(n.p,{children:"The convex hull of all contact points:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from scipy.spatial import ConvexHull\n\ndef compute_support_polygon(contact_points):\n    """Compute support polygon from foot contacts"""\n\n    if len(contact_points) < 3:\n        # Line segment for single or double support\n        return contact_points\n\n    # Convex hull for multiple contacts\n    hull = ConvexHull(contact_points[:, :2])  # 2D projection\n    return contact_points[hull.vertices]\n\ndef is_stable(zmp, support_polygon):\n    """Check if ZMP is inside support polygon"""\n\n    # Use point-in-polygon test\n    from matplotlib.path import Path\n\n    polygon_path = Path(support_polygon[:, :2])\n    return polygon_path.contains_point(zmp[:2])\n'})}),"\n",(0,i.jsx)(n.h2,{id:"gait-patterns",children:"Gait Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"walking-phases",children:"Walking Phases"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Double Support"}),": Both feet on ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Support"}),": One foot on ground, other swinging"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Swing Phase"}),": Moving foot from back to front"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stance Phase"}),": Foot on ground supporting weight"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"gait-cycle",children:"Gait Cycle"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Right Heel Strike \u2192 Left Toe Off \u2192 Left Heel Strike \u2192 Right Toe Off \u2192 Right Heel Strike\n    (Double)         (Single)        (Double)          (Single)        (Double)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"implementing-a-simple-gait",children:"Implementing a Simple Gait"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class GaitGenerator:\n    def __init__(self):\n        self.step_length = 0.2  # meters\n        self.step_height = 0.05  # meters\n        self.step_duration = 1.0  # seconds\n\n    def generate_foot_trajectory(self, t, is_stance):\n        """Generate foot trajectory for swing or stance phase"""\n\n        if is_stance:\n            # Stance foot stays on ground\n            return np.array([0, 0, 0])\n\n        # Swing foot follows trajectory\n        # Normalized time in swing phase (0 to 1)\n        phase = (t % self.step_duration) / self.step_duration\n\n        # Forward motion (straight line)\n        x = self.step_length * phase\n\n        # Vertical motion (parabola)\n        y = 0\n        z = 4 * self.step_height * phase * (1 - phase)\n\n        return np.array([x, y, z])\n\n    def generate_com_trajectory(self, t):\n        """Generate CoM trajectory for stable walking"""\n\n        # Sinusoidal lateral shift during walking\n        phase = (t % self.step_duration) / self.step_duration\n\n        # Shift CoM over stance foot\n        lateral_shift = 0.05 * np.sin(2 * np.pi * phase)\n\n        # Vertical oscillation (reduce impact)\n        vertical = -0.01 * np.cos(2 * np.pi * phase)\n\n        return np.array([0, lateral_shift, vertical])\n'})}),"\n",(0,i.jsx)(n.h2,{id:"preview-control",children:"Preview Control"}),"\n",(0,i.jsx)(n.h3,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,i.jsx)(n.p,{children:"Plan CoM trajectory over future time horizon:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class PreviewController:\n    def __init__(self, horizon=10, dt=0.1):\n        self.horizon = horizon  # Look ahead N steps\n        self.dt = dt\n\n    def compute_com_trajectory(self, current_state, target_zmp):\n        """Compute CoM trajectory that achieves target ZMP"""\n\n        # Simplified linear inverted pendulum model\n        # x_com = [position, velocity]\n\n        A = np.array([[1, self.dt], [0, 1]])\n        B = np.array([[self.dt**2 / 2], [self.dt]])\n\n        # Preview control formulation\n        Q = np.eye(2) * 10  # State weight\n        R = np.eye(1) * 1   # Control weight\n\n        # Solve optimal control problem\n        # Minimize: sum(||x_com - x_desired||^2 + ||u||^2)\n\n        # Simplified implementation\n        com_trajectory = []\n        state = current_state\n\n        for i in range(self.horizon):\n            # Compute control to reach target ZMP\n            zmp_error = target_zmp[i] - self.compute_zmp(state)\n            control = self.compute_optimal_control(state, zmp_error)\n\n            # Update state\n            state = A @ state + B @ control\n            com_trajectory.append(state[0])\n\n        return com_trajectory\n'})}),"\n",(0,i.jsx)(n.h2,{id:"capture-point-theory",children:"Capture Point Theory"}),"\n",(0,i.jsx)(n.h3,{id:"capture-point",children:"Capture Point"}),"\n",(0,i.jsx)(n.p,{children:"The point on the ground where the robot should step to come to a complete stop."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def compute_capture_point(com_pos, com_vel, gravity=9.81):\n    """Compute instantaneous capture point"""\n\n    # For linear inverted pendulum model\n    omega = np.sqrt(gravity / com_pos[2])  # Natural frequency\n\n    # Capture point in x-y plane\n    cp = com_pos[:2] + com_vel[:2] / omega\n\n    return cp\n\ndef compute_footstep_location(capture_point, com_pos):\n    """Determine next footstep location"""\n\n    # Place foot at or near capture point\n    # Add offset for desired walking direction\n\n    footstep = capture_point.copy()\n\n    # Constrain to reachable workspace\n    max_step_length = 0.3\n    step_vector = footstep - com_pos[:2]\n\n    if np.linalg.norm(step_vector) > max_step_length:\n        step_vector = step_vector / np.linalg.norm(step_vector) * max_step_length\n        footstep = com_pos[:2] + step_vector\n\n    return footstep\n'})}),"\n",(0,i.jsx)(n.h2,{id:"linear-inverted-pendulum-model-lipm",children:"Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,i.jsx)(n.p,{children:"Simplified dynamics for walking:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u1e8d = \u03c9\xb2 (x - p)\n\nwhere:\nx = CoM position\np = ZMP position\n\u03c9 = \u221a(g/h), h = CoM height\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class InvertedPendulum:\n    def __init__(self, com_height=0.8, gravity=9.81):\n        self.h = com_height\n        self.g = gravity\n        self.omega = np.sqrt(gravity / com_height)\n\n    def dynamics(self, state, zmp):\n        """Compute CoM dynamics given ZMP"""\n\n        # state = [x, x_dot]\n        x, x_dot = state\n\n        # LIPM dynamics: x_ddot = omega^2 * (x - zmp)\n        x_ddot = self.omega**2 * (x - zmp)\n\n        # Return derivatives [x_dot, x_ddot]\n        return np.array([x_dot, x_ddot])\n\n    def simulate(self, initial_state, zmp_trajectory, dt=0.01):\n        """Simulate LIPM dynamics"""\n\n        state = initial_state\n        trajectory = [state[0]]\n\n        for zmp in zmp_trajectory:\n            # Euler integration\n            derivatives = self.dynamics(state, zmp)\n            state = state + derivatives * dt\n            trajectory.append(state[0])\n\n        return np.array(trajectory)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"whole-body-control",children:"Whole-Body Control"}),"\n",(0,i.jsx)(n.h3,{id:"hierarchical-quadratic-programming-hqp",children:"Hierarchical Quadratic Programming (HQP)"}),"\n",(0,i.jsx)(n.p,{children:"Solve multiple objectives with priority:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High Priority"}),": Contact constraints (feet on ground)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Medium Priority"}),": CoM trajectory tracking"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Low Priority"}),": Joint limit avoidance, posture"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from qpsolvers import solve_qp\n\nclass WholeBodyController:\n    def __init__(self, robot_model):\n        self.robot = robot_model\n\n    def compute_joint_torques(self, desired_com, desired_feet):\n        """Compute joint torques for desired motion"""\n\n        # Get robot state\n        q = self.robot.get_joint_positions()\n        q_dot = self.robot.get_joint_velocities()\n\n        # Compute Jacobians\n        J_com = self.robot.compute_com_jacobian(q)\n        J_left_foot = self.robot.compute_link_jacobian(q, "left_foot")\n        J_right_foot = self.robot.compute_link_jacobian(q, "right_foot")\n\n        # Task: Track CoM trajectory\n        com_error = desired_com - self.robot.compute_com(q)\n        v_com_desired = self.Kp_com * com_error\n\n        # Task: Keep feet fixed (stance phase)\n        v_feet_desired = np.zeros(6)  # Zero velocity for stance\n\n        # Quadratic program formulation\n        # Minimize: ||J_com * q_dot - v_com_desired||^2\n        # Subject to: J_foot * q_dot = 0 (foot contact constraints)\n\n        # QP matrices\n        P = J_com.T @ J_com\n        q = -J_com.T @ v_com_desired\n\n        # Constraints\n        A_eq = np.vstack([J_left_foot, J_right_foot])\n        b_eq = np.zeros(12)  # Both feet fixed\n\n        # Solve QP\n        q_dot_desired = solve_qp(P, q, A=A_eq, b=b_eq)\n\n        # Compute joint torques from desired accelerations\n        tau = self.robot.inverse_dynamics(q, q_dot, q_dot_desired)\n\n        return tau\n'})}),"\n",(0,i.jsx)(n.h2,{id:"practical-exercises",children:"Practical Exercises"}),"\n",(0,i.jsx)(n.h3,{id:"exercise-1-zmp-computation",children:"Exercise 1: ZMP Computation"}),"\n",(0,i.jsx)(n.p,{children:"Implement ZMP calculation and stability check:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# TODO: Student implementation\n# 1. Load humanoid model in simulation\n# 2. Compute CoM and ZMP during walking\n# 3. Visualize ZMP and support polygon\n# 4. Verify stability criterion\n"})}),"\n",(0,i.jsx)(n.h3,{id:"exercise-2-gait-generation",children:"Exercise 2: Gait Generation"}),"\n",(0,i.jsx)(n.p,{children:"Create a simple walking gait:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# TODO: Student implementation\n# 1. Generate foot swing trajectories\n# 2. Generate CoM trajectory\n# 3. Use IK to compute joint angles\n# 4. Simulate in Gazebo/Isaac Sim\n"})}),"\n",(0,i.jsx)(n.h3,{id:"exercise-3-push-recovery",children:"Exercise 3: Push Recovery"}),"\n",(0,i.jsx)(n.p,{children:"Implement balance recovery from external disturbance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# TODO: Student implementation\n# 1. Apply external push to robot\n# 2. Compute capture point\n# 3. Plan recovery footstep\n# 4. Execute stabilizing motion\n"})}),"\n",(0,i.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ZMP must stay inside support polygon for stability"}),"\n",(0,i.jsx)(n.li,{children:"Gait generation requires coordinating foot and CoM trajectories"}),"\n",(0,i.jsx)(n.li,{children:"Linear Inverted Pendulum Model simplifies walking dynamics"}),"\n",(0,i.jsx)(n.li,{children:"Capture Point Theory helps with balance recovery"}),"\n",(0,i.jsx)(n.li,{children:"Whole-body control coordinates all joints for desired motion"}),"\n",(0,i.jsx)(n.li,{children:"Bipedal walking is complex but enables human-like navigation"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.springer.com/gp/book/9783642540950",children:"Introduction to Humanoid Robotics (Kajita et al.)"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"http://underactuated.mit.edu/",children:"MIT Underactuated Robotics Course"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://scaron.info/teaching/zero-tilting-moment-point.html",children:"ZMP Tutorial"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.p,{children:["Continue to ",(0,i.jsx)(n.a,{href:"/docusaurus-robotics-book/pa/module4-vla/manipulation-grasping",children:"Manipulation and Grasping"})," to learn about object interaction."]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var o=t(6540);const i={},r=o.createContext(i);function l(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);