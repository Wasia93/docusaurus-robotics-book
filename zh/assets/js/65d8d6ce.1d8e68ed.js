"use strict";(globalThis.webpackChunkrobotics_book=globalThis.webpackChunkrobotics_book||[]).push([[3530],{8324:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"module4-vla/humanoid-kinematics","title":"Humanoid Robot Kinematics","description":"Overview","source":"@site/docs/module4-vla/humanoid-kinematics.md","sourceDirName":"module4-vla","slug":"/module4-vla/humanoid-kinematics","permalink":"/docusaurus-robotics-book/zh/module4-vla/humanoid-kinematics","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1764862720000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Cognitive Planning with LLMs","permalink":"/docusaurus-robotics-book/zh/module4-vla/cognitive-planning"},"next":{"title":"Bipedal Locomotion","permalink":"/docusaurus-robotics-book/zh/module4-vla/bipedal-locomotion"}}');var o=i(4848),r=i(8453);const a={},s="Humanoid Robot Kinematics",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Humanoid Robot Structure",id:"humanoid-robot-structure",level:2},{value:"Key Components",id:"key-components",level:3},{value:"Degrees of Freedom (DOF)",id:"degrees-of-freedom-dof",level:3},{value:"Forward Kinematics",id:"forward-kinematics",level:2},{value:"Definition",id:"definition",level:3},{value:"Denavit-Hartenberg (DH) Parameters",id:"denavit-hartenberg-dh-parameters",level:3},{value:"Transformation Matrices",id:"transformation-matrices",level:3},{value:"Python Implementation",id:"python-implementation",level:3},{value:"Inverse Kinematics (IK)",id:"inverse-kinematics-ik",level:2},{value:"Definition",id:"definition-1",level:3},{value:"Challenges",id:"challenges",level:3},{value:"Analytical IK (Closed-Form)",id:"analytical-ik-closed-form",level:3},{value:"Numerical IK (Iterative)",id:"numerical-ik-iterative",level:3},{value:"Jacobian-Based IK",id:"jacobian-based-ik",level:3},{value:"URDF and Robot Description",id:"urdf-and-robot-description",level:2},{value:"Loading Robot Model",id:"loading-robot-model",level:3},{value:"Whole-Body IK for Humanoids",id:"whole-body-ik-for-humanoids",level:2},{value:"Multiple End-Effectors",id:"multiple-end-effectors",level:3},{value:"Practical Exercises",id:"practical-exercises",level:2},{value:"Exercise 1: Forward Kinematics",id:"exercise-1-forward-kinematics",level:3},{value:"Exercise 2: Analytical IK",id:"exercise-2-analytical-ik",level:3},{value:"Exercise 3: Numerical IK",id:"exercise-3-numerical-ik",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Resources",id:"resources",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"humanoid-robot-kinematics",children:"Humanoid Robot Kinematics"})}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"Humanoid kinematics studies the motion of humanoid robots without considering forces. Understanding kinematics is essential for controlling the position and orientation of robot links and end-effectors."}),"\n",(0,o.jsx)(n.h2,{id:"humanoid-robot-structure",children:"Humanoid Robot Structure"}),"\n",(0,o.jsx)(n.h3,{id:"key-components",children:"Key Components"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Head\n  \u251c\u2500 Neck (1-3 DOF)\nTorso\n  \u251c\u2500 Spine/Waist (1-3 DOF)\n  \u251c\u2500 Left Arm\n  \u2502   \u251c\u2500 Shoulder (3 DOF)\n  \u2502   \u251c\u2500 Elbow (1-2 DOF)\n  \u2502   \u2514\u2500 Wrist + Hand (3 DOF + fingers)\n  \u251c\u2500 Right Arm (symmetric)\n  \u251c\u2500 Left Leg\n  \u2502   \u251c\u2500 Hip (3 DOF)\n  \u2502   \u251c\u2500 Knee (1 DOF)\n  \u2502   \u2514\u2500 Ankle (2 DOF)\n  \u2514\u2500 Right Leg (symmetric)\n\nTotal DOF: Typically 25-40+ for full humanoid\n"})}),"\n",(0,o.jsx)(n.h3,{id:"degrees-of-freedom-dof",children:"Degrees of Freedom (DOF)"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"DOF"}),": Number of independent parameters defining configuration"]}),"\n",(0,o.jsx)(n.li,{children:"Human body: ~244 DOF (including fingers, spine segments)"}),"\n",(0,o.jsx)(n.li,{children:"Humanoid robots: 25-40 DOF (trade-off between capability and complexity)"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,o.jsx)(n.h3,{id:"definition",children:"Definition"}),"\n",(0,o.jsx)(n.p,{children:"Forward kinematics (FK) computes end-effector pose given joint angles."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Joint Angles \u03b8\u2081, \u03b8\u2082, ..., \u03b8\u2099 \u2192 End-Effector Position & Orientation (x, y, z, roll, pitch, yaw)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"denavit-hartenberg-dh-parameters",children:"Denavit-Hartenberg (DH) Parameters"}),"\n",(0,o.jsx)(n.p,{children:"Standard method for describing robot kinematics:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Link"}),(0,o.jsx)(n.th,{children:"\u03b8 (angle)"}),(0,o.jsx)(n.th,{children:"d (offset)"}),(0,o.jsx)(n.th,{children:"a (length)"}),(0,o.jsx)(n.th,{children:"\u03b1 (twist)"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"1"}),(0,o.jsx)(n.td,{children:"\u03b8\u2081"}),(0,o.jsx)(n.td,{children:"d\u2081"}),(0,o.jsx)(n.td,{children:"a\u2081"}),(0,o.jsx)(n.td,{children:"\u03b1\u2081"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"2"}),(0,o.jsx)(n.td,{children:"\u03b8\u2082"}),(0,o.jsx)(n.td,{children:"d\u2082"}),(0,o.jsx)(n.td,{children:"a\u2082"}),(0,o.jsx)(n.td,{children:"\u03b1\u2082"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"..."}),(0,o.jsx)(n.td,{children:"..."}),(0,o.jsx)(n.td,{children:"..."}),(0,o.jsx)(n.td,{children:"..."}),(0,o.jsx)(n.td,{children:"..."})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"transformation-matrices",children:"Transformation Matrices"}),"\n",(0,o.jsx)(n.p,{children:"Each joint transformation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"T_i = Rot_z(\u03b8) * Trans_z(d) * Trans_x(a) * Rot_x(\u03b1)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Full forward kinematics:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"T_end = T_0 * T_1 * T_2 * ... * T_n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"python-implementation",children:"Python Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import numpy as np\n\ndef dh_transform(theta, d, a, alpha):\n    \"\"\"Compute transformation matrix from DH parameters\"\"\"\n    ct = np.cos(theta)\n    st = np.sin(theta)\n    ca = np.cos(alpha)\n    sa = np.sin(alpha)\n\n    T = np.array([\n        [ct, -st*ca,  st*sa, a*ct],\n        [st,  ct*ca, -ct*sa, a*st],\n        [0,   sa,     ca,    d   ],\n        [0,   0,      0,     1   ]\n    ])\n    return T\n\ndef forward_kinematics(joint_angles, dh_params):\n    \"\"\"Compute end-effector pose from joint angles\"\"\"\n    T = np.eye(4)\n\n    for i, theta in enumerate(joint_angles):\n        theta_total = theta + dh_params[i]['theta_offset']\n        d = dh_params[i]['d']\n        a = dh_params[i]['a']\n        alpha = dh_params[i]['alpha']\n\n        T = T @ dh_transform(theta_total, d, a, alpha)\n\n    return T\n\n# Example: Simple 3-DOF arm\ndh_params = [\n    {'theta_offset': 0, 'd': 0.1, 'a': 0.3, 'alpha': 0},\n    {'theta_offset': 0, 'd': 0,   'a': 0.25, 'alpha': 0},\n    {'theta_offset': 0, 'd': 0,   'a': 0.15, 'alpha': 0}\n]\n\njoint_angles = [np.pi/4, np.pi/6, np.pi/3]\nT_end = forward_kinematics(joint_angles, dh_params)\n\nposition = T_end[:3, 3]\nprint(f\"End-effector position: {position}\")\n"})}),"\n",(0,o.jsx)(n.h2,{id:"inverse-kinematics-ik",children:"Inverse Kinematics (IK)"}),"\n",(0,o.jsx)(n.h3,{id:"definition-1",children:"Definition"}),"\n",(0,o.jsx)(n.p,{children:"Inverse kinematics computes joint angles needed to achieve desired end-effector pose."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Desired Pose (x, y, z, roll, pitch, yaw) \u2192 Joint Angles \u03b8\u2081, \u03b8\u2082, ..., \u03b8\u2099\n"})}),"\n",(0,o.jsx)(n.h3,{id:"challenges",children:"Challenges"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Multiple solutions"}),": Same pose can be reached with different joint configurations"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"No solution"}),": Pose may be out of reach"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Singularities"}),": Some configurations have infinite solutions or no solution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Computational complexity"}),": Non-linear problem, can be slow"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"analytical-ik-closed-form",children:"Analytical IK (Closed-Form)"}),"\n",(0,o.jsx)(n.p,{children:"For simple kinematic chains, solve algebraically:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'def analytical_ik_2dof_arm(target_x, target_y, L1, L2):\n    """Analytical IK for 2-DOF planar arm"""\n\n    # Distance to target\n    D = np.sqrt(target_x**2 + target_y**2)\n\n    # Check reachability\n    if D > (L1 + L2) or D < abs(L1 - L2):\n        return None  # Unreachable\n\n    # Law of cosines for theta2\n    cos_theta2 = (D**2 - L1**2 - L2**2) / (2 * L1 * L2)\n    theta2 = np.arccos(cos_theta2)\n\n    # Two solutions: elbow up, elbow down\n    theta2_solutions = [theta2, -theta2]\n\n    solutions = []\n    for theta2 in theta2_solutions:\n        # Solve for theta1\n        k1 = L1 + L2 * np.cos(theta2)\n        k2 = L2 * np.sin(theta2)\n        theta1 = np.arctan2(target_y, target_x) - np.arctan2(k2, k1)\n\n        solutions.append([theta1, theta2])\n\n    return solutions\n'})}),"\n",(0,o.jsx)(n.h3,{id:"numerical-ik-iterative",children:"Numerical IK (Iterative)"}),"\n",(0,o.jsx)(n.p,{children:"For complex robots, use numerical optimization:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'from scipy.optimize import minimize\n\ndef numerical_ik(target_pose, initial_guess, dh_params):\n    """Numerical IK using optimization"""\n\n    def objective(joint_angles):\n        """Minimize distance between current and target pose"""\n        T_current = forward_kinematics(joint_angles, dh_params)\n        current_pos = T_current[:3, 3]\n        target_pos = target_pose[:3]\n\n        # Position error\n        pos_error = np.linalg.norm(current_pos - target_pos)\n\n        # Optionally add orientation error\n        return pos_error\n\n    result = minimize(\n        objective,\n        initial_guess,\n        method=\'SLSQP\',\n        bounds=[(-np.pi, np.pi)] * len(initial_guess)\n    )\n\n    if result.success:\n        return result.x\n    else:\n        return None\n'})}),"\n",(0,o.jsx)(n.h3,{id:"jacobian-based-ik",children:"Jacobian-Based IK"}),"\n",(0,o.jsx)(n.p,{children:"Use Jacobian matrix for iterative IK:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'def jacobian_ik(target_pose, initial_angles, dh_params, max_iter=100, tol=1e-3):\n    """IK using Jacobian pseudo-inverse method"""\n\n    joint_angles = np.array(initial_angles)\n\n    for _ in range(max_iter):\n        # Current end-effector pose\n        T_current = forward_kinematics(joint_angles, dh_params)\n        current_pos = T_current[:3, 3]\n\n        # Error\n        error = target_pose[:3] - current_pos\n\n        if np.linalg.norm(error) < tol:\n            return joint_angles  # Converged\n\n        # Compute Jacobian numerically\n        J = compute_jacobian(joint_angles, dh_params)\n\n        # Pseudo-inverse\n        J_pinv = np.linalg.pinv(J)\n\n        # Update joint angles\n        delta_theta = J_pinv @ error\n        joint_angles += 0.1 * delta_theta  # Damped update\n\n    return joint_angles  # May not have converged\n\ndef compute_jacobian(joint_angles, dh_params, epsilon=1e-6):\n    """Compute Jacobian numerically"""\n    J = []\n\n    # Current position\n    T_0 = forward_kinematics(joint_angles, dh_params)\n    pos_0 = T_0[:3, 3]\n\n    for i in range(len(joint_angles)):\n        # Perturb joint i\n        angles_perturbed = joint_angles.copy()\n        angles_perturbed[i] += epsilon\n\n        # Compute perturbed position\n        T_perturbed = forward_kinematics(angles_perturbed, dh_params)\n        pos_perturbed = T_perturbed[:3, 3]\n\n        # Finite difference derivative\n        derivative = (pos_perturbed - pos_0) / epsilon\n        J.append(derivative)\n\n    return np.array(J).T\n'})}),"\n",(0,o.jsx)(n.h2,{id:"urdf-and-robot-description",children:"URDF and Robot Description"}),"\n",(0,o.jsx)(n.h3,{id:"loading-robot-model",children:"Loading Robot Model"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import pybullet as p\nimport rclpy\nfrom urdf_parser_py.urdf import URDF\n\ndef load_humanoid_urdf(urdf_path):\n    \"\"\"Load humanoid robot from URDF\"\"\"\n\n    # PyBullet for physics\n    robot_id = p.loadURDF(urdf_path, useFixedBase=False)\n\n    # Get joint info\n    num_joints = p.getNumJoints(robot_id)\n    joint_info = []\n\n    for i in range(num_joints):\n        info = p.getJointInfo(robot_id, i)\n        joint_info.append({\n            'name': info[1].decode('utf-8'),\n            'type': info[2],\n            'lower_limit': info[8],\n            'upper_limit': info[9]\n        })\n\n    return robot_id, joint_info\n"})}),"\n",(0,o.jsx)(n.h2,{id:"whole-body-ik-for-humanoids",children:"Whole-Body IK for Humanoids"}),"\n",(0,o.jsx)(n.h3,{id:"multiple-end-effectors",children:"Multiple End-Effectors"}),"\n",(0,o.jsx)(n.p,{children:"Humanoids often need to control multiple parts simultaneously:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Left hand position"}),"\n",(0,o.jsx)(n.li,{children:"Right hand position"}),"\n",(0,o.jsx)(n.li,{children:"Head orientation"}),"\n",(0,o.jsx)(n.li,{children:"Center of Mass (CoM) position"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'def whole_body_ik(targets, robot_model):\n    """IK for multiple end-effectors"""\n\n    def objective(joint_angles):\n        total_error = 0\n\n        # Set robot configuration\n        robot_model.set_joint_angles(joint_angles)\n\n        # Error for each end-effector\n        for effector, target in targets.items():\n            current_pose = robot_model.get_link_pose(effector)\n            error = np.linalg.norm(current_pose - target)\n            total_error += error\n\n        return total_error\n\n    result = minimize(\n        objective,\n        initial_guess,\n        method=\'SLSQP\',\n        bounds=robot_model.joint_limits\n    )\n\n    return result.x\n'})}),"\n",(0,o.jsx)(n.h2,{id:"practical-exercises",children:"Practical Exercises"}),"\n",(0,o.jsx)(n.h3,{id:"exercise-1-forward-kinematics",children:"Exercise 1: Forward Kinematics"}),"\n",(0,o.jsx)(n.p,{children:"Implement FK for a 3-DOF robot arm:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# TODO: Student implementation\n# 1. Define DH parameters\n# 2. Implement transformation matrices\n# 3. Compute end-effector position\n# 4. Visualize the arm configuration\n"})}),"\n",(0,o.jsx)(n.h3,{id:"exercise-2-analytical-ik",children:"Exercise 2: Analytical IK"}),"\n",(0,o.jsx)(n.p,{children:"Solve IK for a 2-DOF planar arm:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# TODO: Student implementation\n# 1. Implement law of cosines solution\n# 2. Handle both elbow-up and elbow-down solutions\n# 3. Check reachability\n# 4. Visualize both solutions\n"})}),"\n",(0,o.jsx)(n.h3,{id:"exercise-3-numerical-ik",children:"Exercise 3: Numerical IK"}),"\n",(0,o.jsx)(n.p,{children:"Implement iterative IK for a humanoid arm:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# TODO: Student implementation\n# 1. Load humanoid URDF\n# 2. Implement Jacobian computation\n# 3. Implement Jacobian-based IK\n# 4. Test with various target poses\n"})}),"\n",(0,o.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Forward kinematics: joint angles \u2192 end-effector pose"}),"\n",(0,o.jsx)(n.li,{children:"Inverse kinematics: desired pose \u2192 joint angles"}),"\n",(0,o.jsx)(n.li,{children:"Analytical IK is fast but limited to simple chains"}),"\n",(0,o.jsx)(n.li,{children:"Numerical IK handles complex robots but may be slow"}),"\n",(0,o.jsx)(n.li,{children:"Whole-body IK coordinates multiple end-effectors"}),"\n",(0,o.jsx)(n.li,{children:"Singularities and multiple solutions are inherent challenges"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"http://hades.mech.northwestern.edu/index.php/Modern_Robotics",children:"Modern Robotics: Kinematics Textbook"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://docs.google.com/document/d/10sXEhzFRSnvFcl3XxNGhnD4N2SedqwdAvK3dsihxVUA/edit",children:"PyBullet Inverse Kinematics"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://www.springer.com/gp/book/9783642540950",children:"Introduction to Humanoid Robotics"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsxs)(n.p,{children:["Continue to ",(0,o.jsx)(n.a,{href:"/docusaurus-robotics-book/zh/module4-vla/bipedal-locomotion",children:"Bipedal Locomotion"})," to learn about walking and balance control."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var t=i(6540);const o={},r=t.createContext(o);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);