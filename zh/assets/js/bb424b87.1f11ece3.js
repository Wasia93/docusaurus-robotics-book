"use strict";(globalThis.webpackChunkrobotics_book=globalThis.webpackChunkrobotics_book||[]).push([[2688],{2741:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"part1-foundations/control-systems","title":"Control Systems Basics","description":"Fundamental control theory for robotic systems","source":"@site/docs/part1-foundations/04-control-systems.md","sourceDirName":"part1-foundations","slug":"/part1-foundations/control-systems","permalink":"/docusaurus-robotics-book/zh/part1-foundations/control-systems","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1764862720000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Control Systems Basics","description":"Fundamental control theory for robotic systems","keywords":["PID control","feedback control","state space","control theory","stability"]}}');var i=t(4848),r=t(8453);const s={sidebar_position:4,title:"Control Systems Basics",description:"Fundamental control theory for robotic systems",keywords:["PID control","feedback control","state space","control theory","stability"]},l="Control Systems Basics",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Feedback Control",id:"introduction-to-feedback-control",level:2},{value:"PID Control",id:"pid-control",level:2},{value:"PID Tuning",id:"pid-tuning",level:2},{value:"Ziegler-Nichols Method",id:"ziegler-nichols-method",level:3},{value:"Practical Example: Robot Joint Control",id:"practical-example-robot-joint-control",level:2},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"State-Space Control",id:"state-space-control",level:3},{value:"LQR (Linear Quadratic Regulator)",id:"lqr-linear-quadratic-regulator",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Tune PID for Different Systems",id:"exercise-1-tune-pid-for-different-systems",level:3},{value:"Exercise 2: Cascade Control",id:"exercise-2-cascade-control",level:3},{value:"Exercise 3: Disturbance Rejection",id:"exercise-3-disturbance-rejection",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"control-systems-basics",children:"Control Systems Basics"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Estimated Reading Time:"})," 20 minutes\n",(0,i.jsx)(n.strong,{children:"Difficulty:"})," Intermediate\n",(0,i.jsx)(n.strong,{children:"Prerequisites:"})," Basic calculus, Python programming, previous chapters"]}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement PID controllers for robotic systems"}),"\n",(0,i.jsx)(n.li,{children:"Tune PID gains using systematic methods"}),"\n",(0,i.jsx)(n.li,{children:"Understand stability and performance tradeoffs"}),"\n",(0,i.jsx)(n.li,{children:"Apply state-space control methods"}),"\n",(0,i.jsx)(n.li,{children:"Write comprehensive tests for controllers"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-feedback-control",children:"Introduction to Feedback Control"}),"\n",(0,i.jsx)(n.p,{children:"Feedback control systems measure the output and adjust inputs to achieve desired behavior."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nr(t) \u2500\u2192 \u2502 Controller   \u2502 \u2500\u2192 u(t) \u2500\u2192 \u2502 System \u2502 \u2500\u2192 y(t)\n   \u2191    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n   \u2502                                                  \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  Feedback\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"r(t)"})," = reference (setpoint)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"y(t)"})," = output (measurement)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"u(t)"})," = control input"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"e(t) = r(t) - y(t)"})," = error"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"pid-control",children:"PID Control"}),"\n",(0,i.jsx)(n.p,{children:"PID (Proportional-Integral-Derivative) is the most common control algorithm."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class PIDController:\n    """PID controller implementation with anti-windup"""\n\n    def __init__(\n        self,\n        Kp: float,\n        Ki: float,\n        Kd: float,\n        output_limits: tuple[float, float] = (-float(\'inf\'), float(\'inf\'))\n    ):\n        """\n        Initialize PID controller.\n\n        Args:\n            Kp: Proportional gain\n            Ki: Integral gain\n            Kd: Derivative gain\n            output_limits: (min, max) output saturation limits\n        """\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.output_limits = output_limits\n\n        self.integral = 0.0\n        self.last_error = None\n        self.last_time = None\n\n    def update(self, setpoint: float, measurement: float, time: float) -> float:\n        """\n        Calculate control output.\n\n        Args:\n            setpoint: Desired value\n            measurement: Current measured value\n            time: Current time (seconds)\n\n        Returns:\n            Control output u(t)\n        """\n        error = setpoint - measurement\n\n        # Proportional term\n        P = self.Kp * error\n\n        # Integral term\n        if self.last_time is not None:\n            dt = time - self.last_time\n            self.integral += error * dt\n            I = self.Ki * self.integral\n        else:\n            I = 0.0\n\n        # Derivative term\n        if self.last_error is not None and self.last_time is not None:\n            dt = time - self.last_time\n            if dt > 0:\n                derivative = (error - self.last_error) / dt\n                D = self.Kd * derivative\n            else:\n                D = 0.0\n        else:\n            D = 0.0\n\n        # Calculate output\n        output = P + I + D\n\n        # Apply output limits (saturation)\n        output = max(self.output_limits[0], min(output, self.output_limits[1]))\n\n        # Anti-windup: stop integrating if saturated\n        if output == self.output_limits[0] or output == self.output_limits[1]:\n            # Don\'t update integral if output is saturated\n            if self.last_time is not None:\n                self.integral -= error * dt\n\n        self.last_error = error\n        self.last_time = time\n\n        return output\n\n    def reset(self):\n        """Reset controller state"""\n        self.integral = 0.0\n        self.last_error = None\n        self.last_time = None\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Testing PID Controller:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\ndef test_pid_proportional_only():\n    """Test P-controller (Ki=Kd=0)"""\n    controller = PIDController(Kp=1.0, Ki=0.0, Kd=0.0)\n\n    output = controller.update(setpoint=10.0, measurement=5.0, time=0.0)\n\n    # Output should be proportional to error\n    expected = 1.0 * (10.0 - 5.0)\n    assert np.isclose(output, expected)\n\ndef test_pid_integral_accumulation():\n    """Test that integral term accumulates error"""\n    controller = PIDController(Kp=0.0, Ki=1.0, Kd=0.0)\n\n    # Constant error over time\n    outputs = []\n    for t in range(5):\n        output = controller.update(setpoint=10.0, measurement=5.0, time=float(t))\n        outputs.append(output)\n\n    # Integral should accumulate (output increases)\n    assert all(outputs[i] < outputs[i+1] for i in range(len(outputs)-1))\n\ndef test_pid_derivative_response():\n    """Test derivative term responds to rate of change"""\n    controller = PIDController(Kp=0.0, Ki=0.0, Kd=1.0)\n\n    # First measurement\n    output1 = controller.update(setpoint=10.0, measurement=0.0, time=0.0)\n\n    # Error increasing rapidly\n    output2 = controller.update(setpoint=10.0, measurement=5.0, time=1.0)\n\n    # Error increasing slowly\n    controller.reset()\n    controller.update(setpoint=10.0, measurement=0.0, time=0.0)\n    output3 = controller.update(setpoint=10.0, measurement=1.0, time=1.0)\n\n    # Derivative response should be stronger for rapid change\n    assert abs(output2) < abs(output3)\n\ndef test_pid_output_limits():\n    """Test output saturation"""\n    controller = PIDController(\n        Kp=10.0, Ki=0.0, Kd=0.0,\n        output_limits=(-5.0, 5.0)\n    )\n\n    # Large error would produce large output\n    output = controller.update(setpoint=100.0, measurement=0.0, time=0.0)\n\n    # But output should be clamped\n    assert output == 5.0\n\ndef test_pid_anti_windup():\n    """Test anti-windup prevents integral buildup during saturation"""\n    controller = PIDController(\n        Kp=1.0, Ki=1.0, Kd=0.0,\n        output_limits=(-10.0, 10.0)\n    )\n\n    # Saturate the controller\n    for t in range(100):\n        controller.update(setpoint=100.0, measurement=0.0, time=float(t))\n\n    # Now set a reachable setpoint\n    controller.update(setpoint=5.0, measurement=4.0, time=100.0)\n\n    # Without anti-windup, integral would be huge and cause overshoot\n    # With anti-windup, response should be reasonable\n    assert abs(controller.integral) < 200.0  # Reasonable bound\n'})}),"\n",(0,i.jsx)(n.h2,{id:"pid-tuning",children:"PID Tuning"}),"\n",(0,i.jsx)(n.h3,{id:"ziegler-nichols-method",children:"Ziegler-Nichols Method"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def tune_pid_ziegler_nichols(Ku: float, Tu: float, control_type: str = 'PID'):\n    \"\"\"\n    Calculate PID gains using Ziegler-Nichols method.\n\n    Args:\n        Ku: Ultimate gain (gain at which system oscillates)\n        Tu: Ultimate period (oscillation period)\n        control_type: 'P', 'PI', or 'PID'\n\n    Returns:\n        Dictionary with Kp, Ki, Kd values\n    \"\"\"\n    if control_type == 'P':\n        return {'Kp': 0.5 * Ku, 'Ki': 0.0, 'Kd': 0.0}\n    elif control_type == 'PI':\n        return {'Kp': 0.45 * Ku, 'Ki': 0.54 * Ku / Tu, 'Kd': 0.0}\n    elif control_type == 'PID':\n        return {\n            'Kp': 0.6 * Ku,\n            'Ki': 1.2 * Ku / Tu,\n            'Kd': 0.075 * Ku * Tu\n        }\n    else:\n        raise ValueError(f\"Unknown control type: {control_type}\")\n"})}),"\n",(0,i.jsx)(n.h2,{id:"practical-example-robot-joint-control",children:"Practical Example: Robot Joint Control"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class RobotJoint:\n    """Simple robot joint simulation"""\n\n    def __init__(self, inertia: float, damping: float):\n        """\n        Initialize joint.\n\n        Args:\n            inertia: Rotational inertia (kg\u22c5m\xb2)\n            damping: Viscous damping coefficient\n        """\n        self.J = inertia\n        self.b = damping\n        self.position = 0.0\n        self.velocity = 0.0\n\n    def update(self, torque: float, dt: float):\n        """\n        Update joint state given applied torque.\n\n        Args:\n            torque: Applied torque (Nm)\n            dt: Time step (seconds)\n        """\n        # Equation of motion: J\u22c5\u03b8\u0308 + b\u22c5\u03b8\u0307 = \u03c4\n        acceleration = (torque - self.b * self.velocity) / self.J\n        self.velocity += acceleration * dt\n        self.position += self.velocity * dt\n\n\ndef simulate_joint_control():\n    """Simulate PID control of robot joint"""\n    joint = RobotJoint(inertia=0.1, damping=0.05)\n    controller = PIDController(Kp=10.0, Ki=2.0, Kd=1.0, output_limits=(-50, 50))\n\n    target_position = 1.57  # 90 degrees\n    dt = 0.01\n    time = 0.0\n\n    positions = []\n    times = []\n\n    for _ in range(500):\n        # PID control\n        torque = controller.update(target_position, joint.position, time)\n\n        # Update joint\n        joint.update(torque, dt)\n\n        positions.append(joint.position)\n        times.append(time)\n        time += dt\n\n    return times, positions\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Testing Closed-Loop System:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def test_joint_reaches_setpoint():\n    """Test that PID control reaches target position"""\n    joint = RobotJoint(inertia=0.1, damping=0.05)\n    controller = PIDController(Kp=10.0, Ki=2.0, Kd=1.0, output_limits=(-50, 50))\n\n    target = 1.0\n    dt = 0.01\n    time = 0.0\n\n    # Run simulation\n    for _ in range(1000):\n        torque = controller.update(target, joint.position, time)\n        joint.update(torque, dt)\n        time += dt\n\n    # Should reach setpoint within tolerance\n    assert np.isclose(joint.position, target, atol=0.01)\n    # Should be stable (low velocity)\n    assert abs(joint.velocity) < 0.1\n\ndef test_joint_control_stability():\n    """Test that control system is stable (no divergence)"""\n    joint = RobotJoint(inertia=0.1, damping=0.05)\n    controller = PIDController(Kp=10.0, Ki=2.0, Kd=1.0, output_limits=(-50, 50))\n\n    target = 1.0\n    dt = 0.01\n    time = 0.0\n\n    max_position = 0.0\n\n    # Run for extended time\n    for _ in range(2000):\n        torque = controller.update(target, joint.position, time)\n        joint.update(torque, dt)\n        max_position = max(max_position, abs(joint.position))\n        time += dt\n\n    # Position should remain bounded (stable)\n    assert max_position < 2.0  # Shouldn\'t go wild\n\ndef test_joint_control_no_overshoot():\n    """Test that system doesn\'t overshoot significantly"""\n    joint = RobotJoint(inertia=0.1, damping=0.05)\n    controller = PIDController(Kp=5.0, Ki=1.0, Kd=2.0, output_limits=(-50, 50))\n\n    target = 1.0\n    dt = 0.01\n    time = 0.0\n\n    max_position = 0.0\n\n    # Run simulation\n    for _ in range(500):\n        torque = controller.update(target, joint.position, time)\n        joint.update(torque, dt)\n        max_position = max(max_position, joint.position)\n        time += dt\n\n    # Overshoot should be less than 20%\n    overshoot = (max_position - target) / target\n    assert overshoot < 0.2\n'})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,i.jsx)(n.h3,{id:"state-space-control",children:"State-Space Control"}),"\n",(0,i.jsx)(n.p,{children:"State-space representation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u1e8b = Ax + Bu\ny = Cx + Du\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"x"})," = state vector"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"u"})," = input vector"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"y"})," = output vector"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"A, B, C, D"})," = system matrices"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"lqr-linear-quadratic-regulator",children:"LQR (Linear Quadratic Regulator)"}),"\n",(0,i.jsx)(n.p,{children:"Optimal control that minimizes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"J = \u222b(x^T Q x + u^T R u)dt\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Where ",(0,i.jsx)(n.code,{children:"Q"})," and ",(0,i.jsx)(n.code,{children:"R"})," weight state error and control effort."]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This chapter covered:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"PID control implementation with anti-windup"}),"\n",(0,i.jsx)(n.li,{children:"PID tuning methods (Ziegler-Nichols)"}),"\n",(0,i.jsx)(n.li,{children:"Closed-loop system simulation and testing"}),"\n",(0,i.jsx)(n.li,{children:"Stability and performance analysis"}),"\n",(0,i.jsx)(n.li,{children:"Introduction to state-space control"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsx)(n.h3,{id:"exercise-1-tune-pid-for-different-systems",children:"Exercise 1: Tune PID for Different Systems"}),"\n",(0,i.jsx)(n.p,{children:"Implement and tune PID controllers for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fast, lightly-damped system"}),"\n",(0,i.jsx)(n.li,{children:"Slow, heavily-damped system\nCompare performance."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"exercise-2-cascade-control",children:"Exercise 2: Cascade Control"}),"\n",(0,i.jsx)(n.p,{children:"Implement cascade control for a robot joint:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Inner loop: velocity control"}),"\n",(0,i.jsx)(n.li,{children:"Outer loop: position control"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"exercise-3-disturbance-rejection",children:"Exercise 3: Disturbance Rejection"}),"\n",(0,i.jsx)(n.p,{children:"Add external disturbances to the joint simulation. Test how well the PID controller rejects them."}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.p,{children:["This completes ",(0,i.jsx)(n.strong,{children:"Part 1: Foundations"}),". You now have the mathematical and practical foundations for Physical AI systems."]}),"\n",(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.strong,{children:"Part 2: Humanoid Robotics"}),", we'll apply these concepts to bipedal robots, exploring locomotion, manipulation, and human-robot interaction."]}),"\n",(0,i.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://ocw.mit.edu/courses/mechanical-engineering/",children:"Control System Design - MIT OpenCourseWare"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.youtube.com/user/ControlLectures",children:"Brian Douglas Control Tutorials (YouTube)"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://python-control.readthedocs.io/",children:"Python Control Systems Library"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["\ud83d\udca1 ",(0,i.jsx)(n.strong,{children:"Pro Tip"}),": Start with a pure P controller, then add I to eliminate steady-state error, and finally add D to reduce overshoot. Tune one gain at a time."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var o=t(6540);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);