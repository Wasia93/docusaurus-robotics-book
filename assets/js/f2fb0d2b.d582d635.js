"use strict";(globalThis.webpackChunkrobotics_book=globalThis.webpackChunkrobotics_book||[]).push([[6755],{7435:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"part1-foundations/robotics-fundamentals","title":"Robotics Fundamentals","description":"Core mathematical and mechanical principles underlying robotic systems","source":"@site/docs/part1-foundations/02-robotics-fundamentals.md","sourceDirName":"part1-foundations","slug":"/part1-foundations/robotics-fundamentals","permalink":"/part1-foundations/robotics-fundamentals","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1764862720000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Robotics Fundamentals","description":"Core mathematical and mechanical principles underlying robotic systems","keywords":["kinematics","dynamics","forward kinematics","inverse kinematics","robot mechanics"]}}');var i=s(4848),r=s(8453);const a={sidebar_position:2,title:"Robotics Fundamentals",description:"Core mathematical and mechanical principles underlying robotic systems",keywords:["kinematics","dynamics","forward kinematics","inverse kinematics","robot mechanics"]},o="Robotics Fundamentals",c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Robot Coordinate Systems",id:"robot-coordinate-systems",level:2},{value:"Homogeneous Transformations",id:"homogeneous-transformations",level:3},{value:"Testing Transformations",id:"testing-transformations",level:3},{value:"Forward Kinematics",id:"forward-kinematics",level:2},{value:"2-Link Planar Arm Example",id:"2-link-planar-arm-example",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:2},{value:"Robot Dynamics",id:"robot-dynamics",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Equation of Motion",id:"equation-of-motion",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: 3-Link Arm",id:"exercise-1-3-link-arm",level:3},{value:"Exercise 2: Workspace Visualization",id:"exercise-2-workspace-visualization",level:3},{value:"Exercise 3: IK with Obstacles",id:"exercise-3-ik-with-obstacles",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"robotics-fundamentals",children:"Robotics Fundamentals"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Estimated Reading Time:"})," 25 minutes\n",(0,i.jsx)(e.strong,{children:"Difficulty:"})," Beginner to Intermediate\n",(0,i.jsx)(e.strong,{children:"Prerequisites:"})," Linear algebra basics, Python programming"]}),"\n",(0,i.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Understand robot kinematics and dynamics"}),"\n",(0,i.jsx)(e.li,{children:"Calculate forward and inverse kinematics for simple manipulators"}),"\n",(0,i.jsx)(e.li,{children:"Apply coordinate transformations using homogeneous matrices"}),"\n",(0,i.jsx)(e.li,{children:"Implement basic robot motion planning"}),"\n",(0,i.jsx)(e.li,{children:"Write tests for kinematic calculations"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"robot-coordinate-systems",children:"Robot Coordinate Systems"}),"\n",(0,i.jsx)(e.h3,{id:"homogeneous-transformations",children:"Homogeneous Transformations"}),"\n",(0,i.jsx)(e.p,{children:"Robots use homogeneous transformation matrices to represent position and orientation in 3D space."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\ndef create_transform(x, y, z, roll, pitch, yaw):\n    """\n    Create a 4x4 homogeneous transformation matrix.\n\n    Args:\n        x, y, z: Translation in meters\n        roll, pitch, yaw: Rotation in radians\n\n    Returns:\n        4x4 numpy array representing the transformation\n    """\n    # Rotation matrices\n    Rx = np.array([\n        [1, 0, 0],\n        [0, np.cos(roll), -np.sin(roll)],\n        [0, np.sin(roll), np.cos(roll)]\n    ])\n\n    Ry = np.array([\n        [np.cos(pitch), 0, np.sin(pitch)],\n        [0, 1, 0],\n        [-np.sin(pitch), 0, np.cos(pitch)]\n    ])\n\n    Rz = np.array([\n        [np.cos(yaw), -np.sin(yaw), 0],\n        [np.sin(yaw), np.cos(yaw), 0],\n        [0, 0, 1]\n    ])\n\n    # Combined rotation\n    R = Rz @ Ry @ Rx\n\n    # Create homogeneous transformation matrix\n    T = np.eye(4)\n    T[:3, :3] = R\n    T[:3, 3] = [x, y, z]\n\n    return T\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Expected Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"4x4 transformation matrix combining rotation and translation\n"})}),"\n",(0,i.jsx)(e.h3,{id:"testing-transformations",children:"Testing Transformations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import pytest\nimport numpy as np\n\ndef test_identity_transform():\n    """Test that zero transformation is identity"""\n    T = create_transform(0, 0, 0, 0, 0, 0)\n    np.testing.assert_array_almost_equal(T, np.eye(4))\n\ndef test_pure_translation():\n    """Test translation without rotation"""\n    T = create_transform(1.0, 2.0, 3.0, 0, 0, 0)\n    expected_translation = np.array([1.0, 2.0, 3.0])\n    np.testing.assert_array_almost_equal(T[:3, 3], expected_translation)\n    np.testing.assert_array_almost_equal(T[:3, :3], np.eye(3))\n\ndef test_rotation_preserves_distance():\n    """Test that rotation doesn\'t change point distance from origin"""\n    point = np.array([1, 0, 0, 1])\n    T = create_transform(0, 0, 0, 0, 0, np.pi/4)\n    transformed = T @ point\n    original_dist = np.linalg.norm(point[:3])\n    transformed_dist = np.linalg.norm(transformed[:3])\n    assert np.isclose(original_dist, transformed_dist)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,i.jsx)(e.p,{children:"Forward kinematics calculates the end-effector position given joint angles."}),"\n",(0,i.jsx)(e.h3,{id:"2-link-planar-arm-example",children:"2-Link Planar Arm Example"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class TwoLinkArm:\n    """Simple 2-link planar robotic arm"""\n\n    def __init__(self, L1: float, L2: float):\n        """\n        Initialize arm with link lengths.\n\n        Args:\n            L1: Length of first link (meters)\n            L2: Length of second link (meters)\n        """\n        self.L1 = L1\n        self.L2 = L2\n\n    def forward_kinematics(self, theta1: float, theta2: float):\n        """\n        Calculate end-effector position given joint angles.\n\n        Args:\n            theta1: First joint angle (radians)\n            theta2: Second joint angle (radians)\n\n        Returns:\n            (x, y): End-effector position\n        """\n        x = self.L1 * np.cos(theta1) + self.L2 * np.cos(theta1 + theta2)\n        y = self.L1 * np.sin(theta1) + self.L2 * np.sin(theta1 + theta2)\n        return x, y\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Testing Forward Kinematics:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def test_forward_kinematics_zero_angles():\n    """Test FK when all joints at zero"""\n    arm = TwoLinkArm(L1=1.0, L2=1.0)\n    x, y = arm.forward_kinematics(0, 0)\n    assert np.isclose(x, 2.0)\n    assert np.isclose(y, 0.0)\n\ndef test_forward_kinematics_right_angle():\n    """Test FK with 90-degree configuration"""\n    arm = TwoLinkArm(L1=1.0, L2=1.0)\n    x, y = arm.forward_kinematics(0, np.pi/2)\n    assert np.isclose(x, 1.0)\n    assert np.isclose(y, 1.0)\n\ndef test_workspace_limits():\n    """Test that FK respects physical workspace limits"""\n    arm = TwoLinkArm(L1=1.0, L2=1.0)\n    for _ in range(100):\n        theta1 = np.random.uniform(-np.pi, np.pi)\n        theta2 = np.random.uniform(-np.pi, np.pi)\n        x, y = arm.forward_kinematics(theta1, theta2)\n        distance = np.sqrt(x**2 + y**2)\n        # Distance must be within reachable workspace\n        assert distance <= arm.L1 + arm.L2\n        assert distance >= abs(arm.L1 - arm.L2)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,i.jsx)(e.p,{children:"Inverse kinematics (IK) calculates joint angles needed to reach a desired position."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class TwoLinkArm:\n    # ... (previous methods)\n\n    def inverse_kinematics(self, x: float, y: float):\n        """\n        Calculate joint angles to reach target position.\n\n        Args:\n            x, y: Target end-effector position\n\n        Returns:\n            (theta1, theta2): Joint angles in radians\n            Returns None if position unreachable\n\n        Raises:\n            ValueError: If target is outside workspace\n        """\n        distance = np.sqrt(x**2 + y**2)\n\n        # Check if target is reachable\n        if distance > (self.L1 + self.L2) or distance < abs(self.L1 - self.L2):\n            raise ValueError(f"Target ({x}, {y}) is outside workspace")\n\n        # Use law of cosines\n        cos_theta2 = (x**2 + y**2 - self.L1**2 - self.L2**2) / (2 * self.L1 * self.L2)\n        cos_theta2 = np.clip(cos_theta2, -1.0, 1.0)  # Handle numerical errors\n\n        # Two solutions (elbow up/down)\n        theta2 = np.arccos(cos_theta2)\n\n        # Calculate theta1\n        k1 = self.L1 + self.L2 * np.cos(theta2)\n        k2 = self.L2 * np.sin(theta2)\n        theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)\n\n        return theta1, theta2\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Testing Inverse Kinematics:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def test_inverse_kinematics_round_trip():\n    """Test that IK undoes FK"""\n    arm = TwoLinkArm(L1=1.0, L2=1.0)\n\n    # Start with known joint angles\n    theta1_orig, theta2_orig = 0.5, 0.8\n\n    # Calculate end-effector position\n    x, y = arm.forward_kinematics(theta1_orig, theta2_orig)\n\n    # Solve IK to get back to joint angles\n    theta1_computed, theta2_computed = arm.inverse_kinematics(x, y)\n\n    # Verify we reach the same position\n    x_check, y_check = arm.forward_kinematics(theta1_computed, theta2_computed)\n\n    assert np.isclose(x, x_check, atol=1e-6)\n    assert np.isclose(y, y_check, atol=1e-6)\n\ndef test_inverse_kinematics_unreachable():\n    """Test that IK raises error for unreachable targets"""\n    arm = TwoLinkArm(L1=1.0, L2=1.0)\n\n    with pytest.raises(ValueError, match="outside workspace"):\n        arm.inverse_kinematics(3.0, 0.0)  # Too far\n\ndef test_inverse_kinematics_boundary():\n    """Test IK at workspace boundary"""\n    arm = TwoLinkArm(L1=1.0, L2=1.0)\n\n    # Test fully extended position\n    x, y = 2.0, 0.0\n    theta1, theta2 = arm.inverse_kinematics(x, y)\n\n    assert np.isclose(theta1, 0.0, atol=1e-6)\n    assert np.isclose(theta2, 0.0, atol=1e-6)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"robot-dynamics",children:"Robot Dynamics"}),"\n",(0,i.jsx)(e.p,{children:"Dynamics describes how forces and torques produce motion."}),"\n",(0,i.jsx)(e.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Inertia"}),": Resistance to changes in motion"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Gravity"}),": Downward force on each link"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Coriolis/Centrifugal"}),": Forces due to rotation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Friction"}),": Energy dissipation at joints"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"equation-of-motion",children:"Equation of Motion"}),"\n",(0,i.jsx)(e.p,{children:"For a robotic manipulator:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\u03c4 = M(q)q\u0308 + C(q,q\u0307)q\u0307 + G(q)\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"\u03c4"})," = joint torques"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"M(q)"})," = mass/inertia matrix"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"C(q,q\u0307)"})," = Coriolis/centrifugal terms"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"G(q)"})," = gravity vector"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"q, q\u0307, q\u0308"})," = position, velocity, acceleration"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"This chapter covered:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Coordinate transformations using homogeneous matrices"}),"\n",(0,i.jsx)(e.li,{children:"Forward kinematics for calculating end-effector position"}),"\n",(0,i.jsx)(e.li,{children:"Inverse kinematics for solving desired joint angles"}),"\n",(0,i.jsx)(e.li,{children:"Introduction to robot dynamics"}),"\n",(0,i.jsx)(e.li,{children:"Test-driven development for kinematic calculations"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsx)(e.h3,{id:"exercise-1-3-link-arm",children:"Exercise 1: 3-Link Arm"}),"\n",(0,i.jsxs)(e.p,{children:["Extend the ",(0,i.jsx)(e.code,{children:"TwoLinkArm"})," class to support a 3-link planar arm. Implement:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Forward kinematics"}),"\n",(0,i.jsx)(e.li,{children:"Comprehensive unit tests"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"exercise-2-workspace-visualization",children:"Exercise 2: Workspace Visualization"}),"\n",(0,i.jsx)(e.p,{children:"Write code to visualize the reachable workspace of a 2-link arm:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"def plot_workspace(L1, L2):\n    # Your code here: generate points and plot\n    pass\n"})}),"\n",(0,i.jsx)(e.h3,{id:"exercise-3-ik-with-obstacles",children:"Exercise 3: IK with Obstacles"}),"\n",(0,i.jsxs)(e.p,{children:["Modify the IK solver to avoid a circular obstacle at position ",(0,i.jsx)(e.code,{children:"(x_obs, y_obs)"})," with radius ",(0,i.jsx)(e.code,{children:"r"}),"."]}),"\n",(0,i.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(e.p,{children:["Next, we'll explore ",(0,i.jsx)(e.strong,{children:"Sensors and Actuators"}),", covering how robots perceive and act in the physical world."]}),"\n",(0,i.jsx)(e.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"http://hades.mech.northwestern.edu/index.php/Modern_Robotics",children:"Modern Robotics textbook - Lynch & Park"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://cs.stanford.edu/groups/manips/teaching/cs223a/",children:"Introduction to Robotics - Stanford CS223A"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://pyrobotics.readthedocs.io/",children:"PyRobotics library documentation"})}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsxs)(e.p,{children:["\ud83d\udca1 ",(0,i.jsx)(e.strong,{children:"Pro Tip"}),": Always validate IK solutions by running them through FK and checking the result matches the target."]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,s)=>{s.d(e,{R:()=>a,x:()=>o});var t=s(6540);const i={},r=t.createContext(i);function a(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);