"use strict";(globalThis.webpackChunkrobotics_book=globalThis.webpackChunkrobotics_book||[]).push([[3328],{5223:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"part1-foundations/sensors-actuators","title":"Sensors and Actuators","description":"Understanding how robots sense and interact with their environment","source":"@site/docs/part1-foundations/03-sensors-actuators.md","sourceDirName":"part1-foundations","slug":"/part1-foundations/sensors-actuators","permalink":"/docusaurus-robotics-book/part1-foundations/sensors-actuators","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1764862720000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Sensors and Actuators","description":"Understanding how robots sense and interact with their environment","keywords":["sensors","actuators","IMU","encoders","motors","servo","sensor fusion"]}}');var o=t(4848),r=t(8453);const i={sidebar_position:3,title:"Sensors and Actuators",description:"Understanding how robots sense and interact with their environment",keywords:["sensors","actuators","IMU","encoders","motors","servo","sensor fusion"]},a="Sensors and Actuators",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Common Robot Sensors",id:"common-robot-sensors",level:2},{value:"1. Encoders (Position/Velocity)",id:"1-encoders-positionvelocity",level:3},{value:"2. IMU (Inertial Measurement Unit)",id:"2-imu-inertial-measurement-unit",level:3},{value:"3. Lidar (Distance Measurement)",id:"3-lidar-distance-measurement",level:3},{value:"Actuators",id:"actuators",level:2},{value:"DC Motors and Servos",id:"dc-motors-and-servos",level:3},{value:"Sensor Fusion",id:"sensor-fusion",level:2},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Sensor Noise Simulation",id:"exercise-1-sensor-noise-simulation",level:3},{value:"Exercise 2: Multi-Sensor Fusion",id:"exercise-2-multi-sensor-fusion",level:3},{value:"Exercise 3: Motor PID Control",id:"exercise-3-motor-pid-control",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"sensors-and-actuators",children:"Sensors and Actuators"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Estimated Reading Time:"})," 20 minutes\n",(0,o.jsx)(n.strong,{children:"Difficulty:"})," Beginner to Intermediate\n",(0,o.jsx)(n.strong,{children:"Prerequisites:"})," Basic physics, Python programming"]}),"\n",(0,o.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Identify common sensors used in robotics"}),"\n",(0,o.jsx)(n.li,{children:"Understand sensor characteristics (accuracy, precision, noise)"}),"\n",(0,o.jsx)(n.li,{children:"Implement sensor data processing and filtering"}),"\n",(0,o.jsx)(n.li,{children:"Select appropriate actuators for robotic applications"}),"\n",(0,o.jsx)(n.li,{children:"Apply sensor fusion techniques"}),"\n",(0,o.jsx)(n.li,{children:"Write tests for sensor processing code"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(n.p,{children:"Robots interact with the physical world through:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensors"}),": Devices that measure physical quantities (perception)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Actuators"}),": Devices that produce motion or force (action)"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"common-robot-sensors",children:"Common Robot Sensors"}),"\n",(0,o.jsx)(n.h3,{id:"1-encoders-positionvelocity",children:"1. Encoders (Position/Velocity)"}),"\n",(0,o.jsx)(n.p,{children:"Encoders measure rotational position and velocity of motors and joints."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass EncoderReading:\n    """Encoder measurement data"""\n    position: float  # radians\n    velocity: float  # radians/second\n    timestamp: float  # seconds\n\nclass Encoder:\n    """Quadrature encoder for measuring joint position"""\n\n    def __init__(self, resolution: int):\n        """\n        Initialize encoder.\n\n        Args:\n            resolution: Counts per revolution (CPR)\n        """\n        self.resolution = resolution\n        self.counts = 0\n        self.last_time = None\n        self.last_position = None\n\n    def update(self, counts: int, timestamp: float) -> EncoderReading:\n        """\n        Process encoder counts and calculate position/velocity.\n\n        Args:\n            counts: Current encoder count\n            timestamp: Measurement time (seconds)\n\n        Returns:\n            EncoderReading with position and velocity\n        """\n        # Convert counts to radians\n        position = (counts / self.resolution) * 2 * np.pi\n\n        # Calculate velocity\n        if self.last_time is not None:\n            dt = timestamp - self.last_time\n            if dt > 0:\n                velocity = (position - self.last_position) / dt\n            else:\n                velocity = 0.0\n        else:\n            velocity = 0.0\n\n        self.last_time = timestamp\n        self.last_position = position\n\n        return EncoderReading(position, velocity, timestamp)\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Testing Encoder Processing:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'def test_encoder_position():\n    """Test encoder position calculation"""\n    encoder = Encoder(resolution=1000)  # 1000 CPR\n\n    # One full revolution = 1000 counts = 2\u03c0 radians\n    reading = encoder.update(counts=1000, timestamp=1.0)\n\n    assert np.isclose(reading.position, 2 * np.pi)\n\ndef test_encoder_velocity():\n    """Test encoder velocity calculation"""\n    encoder = Encoder(resolution=1000)\n\n    # Initial reading\n    encoder.update(counts=0, timestamp=0.0)\n\n    # After 0.1 seconds, 100 counts (10% of revolution)\n    reading = encoder.update(counts=100, timestamp=0.1)\n\n    expected_velocity = (0.1 * 2 * np.pi) / 0.1  # 0.2\u03c0 rad / 0.1 sec\n    assert np.isclose(reading.velocity, expected_velocity)\n\ndef test_encoder_handles_wraparound():\n    """Test encoder handles count overflow/underflow"""\n    encoder = Encoder(resolution=1000)\n\n    # Simulate wraparound (implementation would need to handle this)\n    # This test documents the expected behavior\n    pass  # TODO: Implement wraparound handling and test\n'})}),"\n",(0,o.jsx)(n.h3,{id:"2-imu-inertial-measurement-unit",children:"2. IMU (Inertial Measurement Unit)"}),"\n",(0,o.jsx)(n.p,{children:"IMUs measure acceleration and angular velocity using accelerometers and gyroscopes."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'@dataclass\nclass IMUReading:\n    """IMU sensor data"""\n    accel_x: float  # m/s\xb2\n    accel_y: float\n    accel_z: float\n    gyro_x: float  # rad/s\n    gyro_y: float\n    gyro_z: float\n    timestamp: float\n\nclass IMUFilter:\n    """Simple complementary filter for IMU data"""\n\n    def __init__(self, alpha: float = 0.98):\n        """\n        Initialize IMU filter.\n\n        Args:\n            alpha: Complementary filter weight (0-1)\n                   Higher = trust gyro more, lower = trust accel more\n        """\n        self.alpha = alpha\n        self.roll = 0.0\n        self.pitch = 0.0\n        self.last_time = None\n\n    def update(self, imu_data: IMUReading) -> tuple[float, float]:\n        """\n        Estimate roll and pitch from IMU data.\n\n        Args:\n            imu_data: Raw IMU measurements\n\n        Returns:\n            (roll, pitch) in radians\n        """\n        # Calculate roll and pitch from accelerometer\n        accel_roll = np.arctan2(imu_data.accel_y, imu_data.accel_z)\n        accel_pitch = np.arctan2(\n            -imu_data.accel_x,\n            np.sqrt(imu_data.accel_y**2 + imu_data.accel_z**2)\n        )\n\n        if self.last_time is not None:\n            dt = imu_data.timestamp - self.last_time\n\n            # Integrate gyro measurements\n            self.roll += imu_data.gyro_x * dt\n            self.pitch += imu_data.gyro_y * dt\n\n            # Complementary filter: combine gyro and accel\n            self.roll = self.alpha * self.roll + (1 - self.alpha) * accel_roll\n            self.pitch = self.alpha * self.pitch + (1 - self.alpha) * accel_pitch\n        else:\n            # Initialize with accelerometer reading\n            self.roll = accel_roll\n            self.pitch = accel_pitch\n\n        self.last_time = imu_data.timestamp\n\n        return self.roll, self.pitch\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Testing IMU Filter:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'def test_imu_filter_static():\n    """Test IMU filter with robot at rest"""\n    imu_filter = IMUFilter(alpha=0.98)\n\n    # Simulate robot flat on ground\n    for i in range(100):\n        imu_data = IMUReading(\n            accel_x=0.0, accel_y=0.0, accel_z=9.81,  # Gravity only\n            gyro_x=0.0, gyro_y=0.0, gyro_z=0.0,      # No rotation\n            timestamp=i * 0.01\n        )\n        roll, pitch = imu_filter.update(imu_data)\n\n    # Should remain near zero\n    assert abs(roll) < 0.05\n    assert abs(pitch) < 0.05\n\ndef test_imu_filter_tilted():\n    """Test IMU filter with robot tilted"""\n    imu_filter = IMUFilter(alpha=0.98)\n\n    # Simulate 45-degree roll\n    roll_angle = np.pi / 4\n    g = 9.81\n\n    for i in range(100):\n        imu_data = IMUReading(\n            accel_x=0.0,\n            accel_y=g * np.sin(roll_angle),\n            accel_z=g * np.cos(roll_angle),\n            gyro_x=0.0, gyro_y=0.0, gyro_z=0.0,\n            timestamp=i * 0.01\n        )\n        roll, pitch = imu_filter.update(imu_data)\n\n    # Should converge to 45 degrees\n    assert np.isclose(roll, roll_angle, atol=0.1)\n'})}),"\n",(0,o.jsx)(n.h3,{id:"3-lidar-distance-measurement",children:"3. Lidar (Distance Measurement)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class LidarSensor:\n    """2D Lidar sensor simulation"""\n\n    def __init__(self, num_rays: int = 360, max_range: float = 10.0):\n        """\n        Initialize Lidar sensor.\n\n        Args:\n            num_rays: Number of rays (angular resolution)\n            max_range: Maximum sensing range (meters)\n        """\n        self.num_rays = num_rays\n        self.max_range = max_range\n        self.angle_increment = 2 * np.pi / num_rays\n\n    def scan(self, obstacles: list) -> np.ndarray:\n        """\n        Simulate lidar scan with obstacles.\n\n        Args:\n            obstacles: List of (x, y, radius) tuples\n\n        Returns:\n            Array of distances for each ray\n        """\n        distances = np.full(self.num_rays, self.max_range)\n\n        for i in range(self.num_rays):\n            angle = i * self.angle_increment\n            # Ray casting logic here\n            # (simplified for demonstration)\n\n        return distances\n\n    def filter_outliers(self, scan: np.ndarray, threshold: float = 0.5) -> np.ndarray:\n        """\n        Remove outlier measurements from scan.\n\n        Args:\n            scan: Raw lidar distances\n            threshold: Maximum allowed change between adjacent rays\n\n        Returns:\n            Filtered scan data\n        """\n        filtered = scan.copy()\n\n        for i in range(1, len(scan) - 1):\n            # Check if measurement differs significantly from neighbors\n            diff_prev = abs(scan[i] - scan[i-1])\n            diff_next = abs(scan[i] - scan[i+1])\n\n            if diff_prev > threshold and diff_next > threshold:\n                # Likely an outlier, replace with median of neighbors\n                filtered[i] = np.median([scan[i-1], scan[i+1]])\n\n        return filtered\n'})}),"\n",(0,o.jsx)(n.h2,{id:"actuators",children:"Actuators"}),"\n",(0,o.jsx)(n.h3,{id:"dc-motors-and-servos",children:"DC Motors and Servos"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class DCMotor:\n    """DC motor model with basic physics"""\n\n    def __init__(self, torque_constant: float, resistance: float, inertia: float):\n        """\n        Initialize DC motor model.\n\n        Args:\n            torque_constant: Nm/A\n            resistance: Ohms\n            inertia: kg\u22c5m\xb2\n        """\n        self.Kt = torque_constant\n        self.R = resistance\n        self.J = inertia\n        self.velocity = 0.0\n        self.position = 0.0\n\n    def update(self, voltage: float, dt: float, load_torque: float = 0.0):\n        """\n        Update motor state given applied voltage.\n\n        Args:\n            voltage: Applied voltage (V)\n            dt: Time step (seconds)\n            load_torque: External load torque (Nm)\n        """\n        # Motor torque from current\n        current = voltage / self.R\n        motor_torque = self.Kt * current\n\n        # Net torque\n        net_torque = motor_torque - load_torque\n\n        # Update velocity (\u03c4 = J\u22c5\u03b1)\n        acceleration = net_torque / self.J\n        self.velocity += acceleration * dt\n\n        # Update position\n        self.position += self.velocity * dt\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Testing Motor Model:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'def test_motor_no_load():\n    """Test motor acceleration with no load"""\n    motor = DCMotor(torque_constant=0.1, resistance=1.0, inertia=0.01)\n\n    # Apply constant voltage\n    for _ in range(100):\n        motor.update(voltage=12.0, dt=0.01, load_torque=0.0)\n\n    # Motor should have accelerated\n    assert motor.velocity > 0\n    assert motor.position > 0\n\ndef test_motor_stall_condition():\n    """Test motor behavior when stalled"""\n    motor = DCMotor(torque_constant=0.1, resistance=1.0, inertia=0.01)\n\n    voltage = 12.0\n    stall_torque = (voltage / motor.R) * motor.Kt\n\n    # Apply load equal to motor torque\n    for _ in range(100):\n        motor.update(voltage=voltage, dt=0.01, load_torque=stall_torque)\n\n    # Motor should not move\n    assert np.isclose(motor.velocity, 0.0, atol=1e-3)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"sensor-fusion",children:"Sensor Fusion"}),"\n",(0,o.jsx)(n.p,{children:"Combining multiple sensors improves accuracy and reliability."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class KalmanFilter1D:\n    """Simple 1D Kalman filter for sensor fusion"""\n\n    def __init__(self, process_noise: float, measurement_noise: float):\n        """\n        Initialize Kalman filter.\n\n        Args:\n            process_noise: Process uncertainty\n            measurement_noise: Measurement uncertainty\n        """\n        self.Q = process_noise\n        self.R = measurement_noise\n        self.x = 0.0  # State estimate\n        self.P = 1.0  # Estimation uncertainty\n\n    def predict(self, dt: float):\n        """Prediction step"""\n        # State doesn\'t change (constant velocity model would be different)\n        # Uncertainty increases\n        self.P += self.Q * dt\n\n    def update(self, measurement: float):\n        """Update step with new measurement"""\n        # Kalman gain\n        K = self.P / (self.P + self.R)\n\n        # Update estimate\n        self.x = self.x + K * (measurement - self.x)\n\n        # Update uncertainty\n        self.P = (1 - K) * self.P\n\n    def get_estimate(self) -> float:\n        """Get current state estimate"""\n        return self.x\n'})}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"This chapter covered:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Common robot sensors (encoders, IMUs, Lidar)"}),"\n",(0,o.jsx)(n.li,{children:"Sensor data processing and filtering"}),"\n",(0,o.jsx)(n.li,{children:"Actuator models (DC motors)"}),"\n",(0,o.jsx)(n.li,{children:"Sensor fusion with Kalman filters"}),"\n",(0,o.jsx)(n.li,{children:"Test-driven development for sensor/actuator code"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsx)(n.h3,{id:"exercise-1-sensor-noise-simulation",children:"Exercise 1: Sensor Noise Simulation"}),"\n",(0,o.jsx)(n.p,{children:"Add realistic noise to the encoder and IMU sensor models. Test that filters can handle noisy data."}),"\n",(0,o.jsx)(n.h3,{id:"exercise-2-multi-sensor-fusion",children:"Exercise 2: Multi-Sensor Fusion"}),"\n",(0,o.jsx)(n.p,{children:"Implement a Kalman filter that fuses encoder and IMU data to estimate robot position."}),"\n",(0,o.jsx)(n.h3,{id:"exercise-3-motor-pid-control",children:"Exercise 3: Motor PID Control"}),"\n",(0,o.jsx)(n.p,{children:"Implement a PID controller for the DC motor to reach and maintain a target velocity."}),"\n",(0,o.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsxs)(n.p,{children:["In the next chapter, we'll explore ",(0,o.jsx)(n.strong,{children:"Control Systems"}),", covering PID control, state-space methods, and modern control techniques."]}),"\n",(0,o.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://www.kalmanfilter.net/",children:"Kalman Filter Interactive Guide"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://www.coursera.org/learn/sensor-fusion",children:"Sensor Fusion Tutorial - Coursera"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://learn.sparkfun.com/tutorials/accelerometer-basics",children:"IMU Basics - SparkFun"})}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:["\ud83d\udca1 ",(0,o.jsx)(n.strong,{children:"Pro Tip"}),": Always characterize your sensors in the actual deployment environment - sensor specifications are often best-case values."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(6540);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);