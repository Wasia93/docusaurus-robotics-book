"use strict";(globalThis.webpackChunkrobotics_book=globalThis.webpackChunkrobotics_book||[]).push([[336],{5976:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"part2-humanoid/bipedal-locomotion","title":"Bipedal Locomotion","description":"Walking and balance control for humanoid robots","source":"@site/docs/part2-humanoid/01-bipedal-locomotion.md","sourceDirName":"part2-humanoid","slug":"/part2-humanoid/bipedal-locomotion","permalink":"/docusaurus-robotics-book/part2-humanoid/bipedal-locomotion","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1764862720000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Bipedal Locomotion","description":"Walking and balance control for humanoid robots","keywords":["bipedal locomotion","walking","balance","ZMP","gait","humanoid"]}}');var i=t(4848),r=t(8453);const a={sidebar_position:1,title:"Bipedal Locomotion",description:"Walking and balance control for humanoid robots",keywords:["bipedal locomotion","walking","balance","ZMP","gait","humanoid"]},s="Bipedal Locomotion",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Stability Concepts",id:"stability-concepts",level:2},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Gait Generation",id:"gait-generation",level:2},{value:"Walking Pattern Generator",id:"walking-pattern-generator",level:3},{value:"Balance Control",id:"balance-control",level:2},{value:"COM Trajectory Planning",id:"com-trajectory-planning",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Support Polygon",id:"exercise-1-support-polygon",level:3},{value:"Exercise 2: Dynamic Walking",id:"exercise-2-dynamic-walking",level:3},{value:"Exercise 3: Push Recovery",id:"exercise-3-push-recovery",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"bipedal-locomotion",children:"Bipedal Locomotion"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Estimated Reading Time:"})," 25 minutes\n",(0,i.jsx)(e.strong,{children:"Difficulty:"})," Advanced\n",(0,i.jsx)(e.strong,{children:"Prerequisites:"})," Part 1 complete, especially kinematics and control systems"]}),"\n",(0,i.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Understand the challenges of bipedal walking"}),"\n",(0,i.jsx)(e.li,{children:"Implement Zero Moment Point (ZMP) control"}),"\n",(0,i.jsx)(e.li,{children:"Generate walking gaits using trajectory planning"}),"\n",(0,i.jsx)(e.li,{children:"Apply balance control strategies"}),"\n",(0,i.jsx)(e.li,{children:"Test locomotion controllers in simulation"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(e.p,{children:"Bipedal locomotion is one of the most challenging problems in robotics. Unlike wheeled or quadruped robots, bipedal robots:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Are inherently unstable"}),"\n",(0,i.jsx)(e.li,{children:"Have a small support polygon"}),"\n",(0,i.jsx)(e.li,{children:"Must continuously manage center of mass"}),"\n",(0,i.jsx)(e.li,{children:"Require coordinated multi-joint control"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"stability-concepts",children:"Stability Concepts"}),"\n",(0,i.jsx)(e.h3,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,i.jsx)(e.p,{children:"The ZMP is the point on the ground where the net moment from ground reaction forces is zero."}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Stability Condition"}),": Robot is stable if ZMP is inside the support polygon (foot contact area)."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom dataclasses import dataclass\n\n@dataclass\nclass RobotState:\n    """Humanoid robot state"""\n    com_position: np.ndarray  # Center of mass [x, y, z]\n    com_velocity: np.ndarray\n    com_acceleration: np.ndarray\n    foot_positions: dict  # {\'left\': [x,y,z], \'right\': [x,y,z]}\n\nclass ZMPCalculator:\n    """Calculate Zero Moment Point for balance"""\n\n    def __init__(self, mass: float, gravity: float = 9.81):\n        """\n        Initialize ZMP calculator.\n\n        Args:\n            mass: Total robot mass (kg)\n            gravity: Gravitational acceleration (m/s\xb2)\n        """\n        self.mass = mass\n        self.g = gravity\n\n    def calculate_zmp(self, state: RobotState) -> tuple[float, float]:\n        """\n        Calculate ZMP position.\n\n        Args:\n            state: Current robot state\n\n        Returns:\n            (zmp_x, zmp_y): ZMP coordinates on ground\n        """\n        # Simplified ZMP calculation (assumes flat ground)\n        com_height = state.com_position[2]\n\n        zmp_x = state.com_position[0] - (com_height / self.g) * state.com_acceleration[0]\n        zmp_y = state.com_position[1] - (com_height / self.g) * state.com_acceleration[1]\n\n        return zmp_x, zmp_y\n\n    def is_stable(\n        self,\n        zmp: tuple[float, float],\n        support_polygon: list[tuple[float, float]]\n    ) -> bool:\n        """\n        Check if ZMP is inside support polygon.\n\n        Args:\n            zmp: (x, y) ZMP position\n            support_polygon: List of (x, y) vertices\n\n        Returns:\n            True if stable (ZMP inside polygon)\n        """\n        # Point-in-polygon test\n        # TODO: Implement proper point-in-polygon algorithm\n        return True  # Placeholder\n'})}),"\n",(0,i.jsx)(e.h2,{id:"gait-generation",children:"Gait Generation"}),"\n",(0,i.jsx)(e.h3,{id:"walking-pattern-generator",children:"Walking Pattern Generator"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class WalkingGaitGenerator:\n    """Generate walking trajectories"""\n\n    def __init__(\n        self,\n        step_length: float,\n        step_height: float,\n        step_duration: float\n    ):\n        """\n        Initialize gait generator.\n\n        Args:\n            step_length: Length of each step (m)\n            step_height: Maximum foot height during swing (m)\n            step_duration: Time for one step (seconds)\n        """\n        self.step_length = step_length\n        self.step_height = step_height\n        self.step_duration = step_duration\n\n    def generate_foot_trajectory(\n        self,\n        start_pos: np.ndarray,\n        end_pos: np.ndarray,\n        t: float\n    ) -> np.ndarray:\n        """\n        Generate swing foot trajectory.\n\n        Args:\n            start_pos: Starting foot position [x, y, z]\n            end_pos: Ending foot position [x, y, z]\n            t: Time in step cycle (0 to 1)\n\n        Returns:\n            Current foot position [x, y, z]\n        """\n        # Cubic polynomial for smooth trajectory\n        s = 3 * t**2 - 2 * t**3  # Smooth interpolation (0 to 1)\n\n        # Horizontal motion\n        pos = start_pos + s * (end_pos - start_pos)\n\n        # Vertical motion (parabolic arc)\n        if 0 < t < 1:\n            pos[2] += self.step_height * 4 * t * (1 - t)\n\n        return pos\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Testing Gait Generation:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'def test_foot_trajectory_starts_at_origin():\n    """Test that trajectory starts at specified position"""\n    generator = WalkingGaitGenerator(\n        step_length=0.3,\n        step_height=0.05,\n        step_duration=0.5\n    )\n\n    start = np.array([0.0, 0.0, 0.0])\n    end = np.array([0.3, 0.0, 0.0])\n\n    pos = generator.generate_foot_trajectory(start, end, t=0.0)\n    np.testing.assert_array_almost_equal(pos, start)\n\ndef test_foot_trajectory_ends_at_target():\n    """Test that trajectory ends at specified position"""\n    generator = WalkingGaitGenerator(\n        step_length=0.3,\n        step_height=0.05,\n        step_duration=0.5\n    )\n\n    start = np.array([0.0, 0.0, 0.0])\n    end = np.array([0.3, 0.0, 0.0])\n\n    pos = generator.generate_foot_trajectory(start, end, t=1.0)\n    np.testing.assert_array_almost_equal(pos, end)\n\ndef test_foot_clears_obstacle():\n    """Test that foot reaches specified clearance height"""\n    generator = WalkingGaitGenerator(\n        step_length=0.3,\n        step_height=0.05,\n        step_duration=0.5\n    )\n\n    start = np.array([0.0, 0.0, 0.0])\n    end = np.array([0.3, 0.0, 0.0])\n\n    # Check midpoint of swing\n    pos = generator.generate_foot_trajectory(start, end, t=0.5)\n\n    # Should be at maximum height\n    assert pos[2] >= 0.04  # Near step_height\n'})}),"\n",(0,i.jsx)(e.h2,{id:"balance-control",children:"Balance Control"}),"\n",(0,i.jsx)(e.h3,{id:"com-trajectory-planning",children:"COM Trajectory Planning"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class COMController:\n    """Center of Mass trajectory controller"""\n\n    def __init__(self, com_height: float):\n        """\n        Initialize COM controller.\n\n        Args:\n            com_height: Desired COM height (m)\n        """\n        self.com_height = com_height\n\n    def generate_com_trajectory(\n        self,\n        current_com: np.ndarray,\n        target_zmp: np.ndarray,\n        dt: float\n    ) -> np.ndarray:\n        """\n        Generate COM trajectory to achieve desired ZMP.\n\n        Args:\n            current_com: Current COM position [x, y, z]\n            target_zmp: Desired ZMP position [x, y]\n            dt: Time step\n\n        Returns:\n            Desired COM acceleration [ax, ay, az]\n        """\n        # Simplified preview control\n        # Real implementation would use more sophisticated control\n\n        g = 9.81\n        omega = np.sqrt(g / self.com_height)\n\n        # Proportional control of COM based on ZMP error\n        Kp = omega**2\n\n        com_acceleration = np.zeros(3)\n        com_acceleration[0] = Kp * (current_com[0] - target_zmp[0])\n        com_acceleration[1] = Kp * (current_com[1] - target_zmp[1])\n\n        return com_acceleration\n'})}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"This chapter covered:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"ZMP stability criterion for bipedal robots"}),"\n",(0,i.jsx)(e.li,{children:"Walking gait generation with foot trajectories"}),"\n",(0,i.jsx)(e.li,{children:"Center of mass control for balance"}),"\n",(0,i.jsx)(e.li,{children:"Test-driven development for locomotion"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsx)(e.h3,{id:"exercise-1-support-polygon",children:"Exercise 1: Support Polygon"}),"\n",(0,i.jsxs)(e.p,{children:["Implement the point-in-polygon test for the ",(0,i.jsx)(e.code,{children:"is_stable()"})," method."]}),"\n",(0,i.jsx)(e.h3,{id:"exercise-2-dynamic-walking",children:"Exercise 2: Dynamic Walking"}),"\n",(0,i.jsx)(e.p,{children:"Extend the gait generator to support variable step length and turning."}),"\n",(0,i.jsx)(e.h3,{id:"exercise-3-push-recovery",children:"Exercise 3: Push Recovery"}),"\n",(0,i.jsx)(e.p,{children:"Simulate a push disturbance and implement a controller to recover balance."}),"\n",(0,i.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(e.p,{children:["Next chapter: ",(0,i.jsx)(e.strong,{children:"Motion Planning"})," for collision-free humanoid navigation."]}),"\n",(0,i.jsx)(e.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://link.springer.com/book/10.1007/978-3-642-54536-8",children:"Introduction to Humanoid Robotics - Kajita"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"http://underactuated.mit.edu/",children:"Bipedal Walking - MIT Course"})}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsxs)(e.p,{children:["\ud83d\udca1 ",(0,i.jsx)(e.strong,{children:"Pro Tip"}),": Always test walking controllers in simulation with realistic ground contact models before deploying on hardware."]})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>s});var o=t(6540);const i={},r=o.createContext(i);function a(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);